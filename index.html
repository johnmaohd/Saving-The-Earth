<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Saving The Earth üöÄ„Ä∞Ô∏èüõ∏</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body,
    html {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000022;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
    }

    #flightContainer {
      flex: 1;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
    }

    button {
      padding: 5px 15px;
      font-size: 14px;
    }

    #score {
      position: absolute;
      top: 10px;
      right: 10px;
      /* Position score to the right */
      color: white;
      font-size: 18px;
      font-weight: bold;
      z-index: 1001;
    }

    #earthHealthContainer {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      /* Use flexbox for alignment */
      align-items: center;
      /* Vertically align items in the middle */
      z-index: 1000;
      /* Ensure it's above the canvas */
      color: white;
      /* Text color for label */
      font-family: 'Arial', sans-serif;
      font-size: 14px;
      font-weight: bold;
    }

    #earthHealthLabel {
      margin-right: 8px;
      /* Space between label and bar */
    }

    #livesDisplayContainer {
      position: absolute;
      top: 35px;
      /* Below Earth health */
      left: 10px;
      display: flex;
      align-items: center;
      color: white;
      font-family: 'Arial', sans-serif;
      font-size: 14px;
      font-weight: bold;
      z-index: 1000;
    }

    #livesLabel {
      margin-right: 5px;
    }

    #livesIcons img {
      width: 50px;
      /* Increased size (20px * 1.5) */
      height: auto;
      margin-left: 1px;
      /* Slightly increased margin for larger, rotated icons */
      transform: rotate(-45deg);
      /* Rotate 45 degrees counter-clockwise */
      /* Optional: Adjust vertical alignment if needed after rotation */
      /* vertical-align: middle; */
    }

    #earthHealthBarOuter {
      width: 150px;
      /* Adjust width for the bar itself */
      height: 18px;
      /* Adjust height for the bar itself */
      border: 2px solid #FFF;
      background-color: #555;
      border-radius: 5px;
      padding: 1px;
      /* Small padding so inner bar doesn't touch border */
    }

    #earthHealthBar {
      height: 100%;
      width: 100%;
      /* Starts full */
      background-color: #4CAF50;
      /* Green for health */
      border-radius: 3px;
      /* Slightly rounded inner bar */
      transition: width 0.1s linear;
      /* Smooth transition for health changes */
    }

    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 20px;
      text-align: center;
      font-size: 24px;
      display: none;
      z-index: 1002;
    }

    #gameOver button {
      background-color: #7bc307;
      /* Un rosa vibrante o el color que prefieras */
      color: white;
      border: none;
      border-radius: 25px;
      /* Esquinas bien redondeadas */
      padding: 12px 25px;
      /* M√°s relleno */
      font-size: 18px;
      /* Un poco m√°s grande */
      font-weight: bold;
      font-family: 'Arial', sans-serif;
      /* O una fuente m√°s "juguetona" si la tienes */
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
      margin-top: 20px;
      /* M√°s espacio arriba */
    }

    #gameOver button:hover {
      background-color: #77f10a;
      /* Un tono m√°s oscuro del rosa */
      transform: translateY(-3px) scale(1.05);
      /* Efecto de levantarse y crecer un poco */
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
      color: #717af9;
    }

    #gameOver button:active {
      background-color: #C51162;
      /* A√∫n m√°s oscuro al hacer clic */
      transform: translateY(0px) scale(1);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    #startScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      /* Cambiado a flex para mostrar por defecto */
      flex-direction: column;
      align-items: center;
      text-align: center;
      z-index: 1003;
      /* Encima de todo lo dem√°s inicialmente */
    }

    #startScreen img {
      max-width: 80%;
      /* Ajusta seg√∫n sea necesario */
      height: auto;
      margin-bottom: 30px;
      /* Espacio entre imagen y bot√≥n */
      border: 3px solid #7bc307;
      /* Borde verde como el bot√≥n */
      border-radius: 10px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
    }

    #startGameBtn {
      background-color: #7bc307;
      /* Verde como el de reiniciar */
      color: white;
      border: none;
      border-radius: 25px;
      padding: 15px 35px;
      /* Un poco m√°s grande */
      font-size: 22px;
      /* M√°s grande */
      font-weight: bold;
      font-family: 'Arial', sans-serif;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    }

    #startGameBtn:hover {
      background-color: #6aa805;
      /* Verde m√°s oscuro */
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    }

    #startGameBtn:active {
      background-color: #589004;
      /* Verde a√∫n m√°s oscuro */
      transform: translateY(0px) scale(1);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    /* Ocultar elementos de la UI del juego inicialmente */
    #score,
    #earthHealthContainer,
    #livesDisplayContainer {
      display: none;
    }
  </style>
</head>

<body>

  <div id="earthHealthContainer">
    <span id="earthHealthLabel">Earth Shield:</span>
    <div id="earthHealthBarOuter">
      <div id="earthHealthBar"></div>
    </div>
  </div>
  <div id="score">Puntuaci√≥n: 0</div>
  <div id="livesDisplayContainer">
    <span id="livesLabel">Lives: </span>
    <div id="livesIcons"></div>
  </div>
  <div id="gameOver">
    <div id="gameOverMessage">¬°Juego Terminado!</div>
    <button id="restartBtn">Reiniciar Juego</button>
  </div>

  <div id="startScreen">
    <img src="portada.png" alt="Saving Earth Portada">
    <button id="startGameBtn">INICIAR</button>
  </div>

  <div id="flightContainer">
    <canvas id="flightCanvas"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("flightCanvas");
    const ctx = canvas.getContext("2d");
    const gameOverDiv = document.getElementById('gameOver');
    const gameOverMessage = document.getElementById('gameOverMessage');
    const restartBtn = document.getElementById('restartBtn');

    // Elementos de la pantalla de inicio
    const startScreenDiv = document.getElementById('startScreen');
    const startGameBtn = document.getElementById('startGameBtn');
    console.log('startGameBtn element:', startGameBtn); // DEBUG
    // Estas ya est√°n declaradas globalmente m√°s abajo, nos aseguraremos de que esas globales se usen.
    // const scoreDisplay = document.getElementById('score'); 
    const earthHealthBarDiv = document.getElementById('earthHealthBar');
    const livesDisplayDiv = document.getElementById('livesIcons'); // Get the div for life icons
    // No se necesita obtener scoreDisplay aqu√≠, ya que se obtiene globalmente como scoreDisplayGlobal

    // --- C√≥digo para cargar Sonidos ---
    const audioLaser = new Audio('laser.wav'); // Nuevo sonido para el disparo
    const audioAtmosfera = new Audio('sonido_atmosferico.mp3'); // Ensure 'sonido_atmosferico.mp3' exists
    const audioPlayerExplosion = new Audio('explosion-nave.mp3'); // Sound for player explosion
    const audioInvaderDown = new Audio('invader_down.wav');   // Sound for martian destroyed by bullet
    const audioEarthBang = new Audio('earth_bang.wav');     // Sound for Earth explosion
    const audioPremio = new Audio('premio.mp3'); // Sound for starting the game
    const audioVoz = new Audio('voz.mp3'); // Sound for initial voice

    function playSound(sound) {
      if (sound && typeof sound.play === 'function') {
        sound.currentTime = 0;
        sound.play().catch(e => console.warn("Audio play failed for " + (sound.src || 'unknown sound') + ":", e));
      }
    }

    // --- Fin del c√≥digo para cargar Sonidos ---

    // Referencias GLOBALES a elementos de la UI del juego que se mostrar√°n/ocultar√°n
    // Estas se usan en initializeOrResetGame y updateUI
    const scoreDisplayGlobal = document.getElementById('score');
    const earthHealthContainerGlobal = document.getElementById('earthHealthContainer');
    const livesDisplayContainerGlobal = document.getElementById('livesDisplayContainer');
    // Nota: 'scoreDisplay' (sin Global) se obtiene localmente en updateUI, lo cual est√° bien.

    let gameIsOver = false;
    let gameHasStarted = false;

    // --- C√≥digo para cargar im√°genes ---
    const playerImage = new Image();
    playerImage.onload = imageLoaded;
    playerImage.src = "nave.png";

    const invaderImage = new Image();
    invaderImage.onload = imageLoaded;
    invaderImage.src = 'invader.png';

    const invaderRojoImage = new Image();
    invaderRojoImage.onload = imageLoaded;
    invaderRojoImage.src = 'invader_rojo.png';

    let planeta = { img: null, x: 0, y: 0, width: 0, height: 0, targetY: 0, speed: 0, loaded: false, reachedTarget: false }; // Planeta state

    const planetaImage = new Image();
    planetaImage.onload = imageLoaded;
    planetaImage.src = "planeta.png";

    // For sounds, 'oncanplaythrough' is often more appropriate than 'onload'
    // The existing imageLoaded function will just increment the counter if 'this' is not a known image.
    audioEarthBang.oncanplaythrough = imageLoaded;
    audioEarthBang.load(); // Explicitly call load for audio elements

    // Tama√±os deseados para las im√°genes (ajustar si es necesario)
    const playerImgWidth = 100; // 30 * 1.5
    const playerImgHeight = 100; // 30 * 1.5
    const invaderImgWidth = 50; // Doubled size
    const invaderImgHeight = 50; // Doubled size

    // Martian base speeds
    let martianBaseSpeedX = 1; // Base for horizontal speed calculation
    let martianBaseSpeedY = 0.15; // Base vertical speed

    let imagesLoadedCount = 0;
    const totalImagesToLoad = 5; // Actualizado: 4 im√°genes + 1 sonido (earth_bang)

    // Funci√≥n que se llama cuando una imagen ha terminado de cargar
    function imageLoaded() {
      if (this === planetaImage) {
        planeta.img = this; // Assign the loaded image object to planeta.img
        planeta.loaded = true;
        planeta.width = this.naturalWidth;
        planeta.height = this.naturalHeight;
        planeta.x = (width - planeta.width) / 2;
        planeta.y = height; // Start below screen
        planeta.targetY = height - (planeta.height / 2);
        // Calculate speed for 1-minute animation (assuming 60 FPS)
        // Distance to travel = planeta.height / 2
        // Frames in 1 minute = 60 seconds * 60 FPS = 3600 frames
        if (planeta.height > 0) { // Avoid division by zero if image fails to load height
          planeta.speed = (planeta.height / 2) / (60 * 60);
        } else {
          planeta.speed = 0.1; // Fallback speed if height is not available
        }
      }

      imagesLoadedCount++;
      if (imagesLoadedCount === totalImagesToLoad) {
        // Todas las im√°genes est√°n cargadas, iniciar el bucle de animaci√≥n
        createStars(); // Initialize stars
        for (let i = 0; i < 3; i++) createMartian(); // Create some initial martians
        animate();
      }
    }
    // --- Fin del c√≥digo para cargar im√°genes ---
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    window.addEventListener("resize", () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;

      if (planeta.loaded) {
        planeta.x = (width - planeta.width) / 2;
        const newTargetY = height - (planeta.height / 2);
        if (planeta.reachedTarget) {
          planeta.y = newTargetY; // Keep it at its relative half-visible position
        }
        planeta.targetY = newTargetY; // Update target for ongoing animation or if reset
        // If not reached target and animation is ongoing, it will adjust towards new targetY.
        // For a full reset on resize before target: 
        // if (!planeta.reachedTarget) { planeta.y = height; }
      }
    });

    // Estado del avi√≥n
    let playerDestroyed = false;
    let isGameOver = false; // Ensure it's globally defined
    let firstShotFired = false; // For initial sound logic
    let atmosphericSoundHasStarted = false; // For initial sound logic
    let position = { x: width / 2, y: height / 2 };
    let angle = 0;
    // let speed = 0; // Original initial speed, now initialized to actualMinSpeed

    // Planeta state is now declared globally earlier

    // Variables para la f√≠sica de rotaci√≥n suave
    let rotationSpeed = 0;

    // Variables para la salud de la Tierra
    const MAX_EARTH_HEALTH = 100;
    let earthHealth = MAX_EARTH_HEALTH;
    const earthHealthFill = document.getElementById('earth-health-fill');
    const earthHealthText = document.getElementById('earth-health-text');
    let lastHealthDrainTime = 0; // Will be set to Date.now() when game starts/resets
    const healthDrainInterval = 1000; // 1 second in milliseconds
    const maxRotationSpeed = Math.PI / 180 * 2.5; // M√°ximo 2.5 grados por frame
    const rotationAcceleration = Math.PI / 180 * 0.15; // Aceleraci√≥n de 0.15 grados por frame
    const rotationDamping = 0.92; // Factor de amortiguaci√≥n para la rotaci√≥n
    let maxSpeed = 8;
    const actualMinSpeed = maxSpeed * 0.10; // Minimum speed is 10% of maxSpeed
    let speed = actualMinSpeed; // Initialize speed to minimum speed
    let accelerationFactor = 0.03;
    // const minSpeed = 0.5; // Old minSpeed (0.5), replaced by actualMinSpeed

    // Controles por teclado
    const keys = {
      up: false,
      down: false,
      left: false,
      right: false
    };

    document.addEventListener("keydown", (e) => {
      if (e.code === "ArrowUp") keys.up = true;
      if (e.code === "ArrowDown") keys.down = true;
      if (e.code === "ArrowLeft") keys.left = true;
      if (e.code === "ArrowRight") keys.right = true;
      if (e.code === "Space") shoot();
    });

    document.addEventListener("keyup", (e) => {
      if (e.code === "ArrowUp") keys.up = false;
      if (e.code === "ArrowDown") keys.down = false;
      if (e.code === "ArrowLeft") keys.left = false;
      if (e.code === "ArrowRight") keys.right = false;
    });

    // Estrellas
    let stars = [];

    // Balas (siempre m√°s veloz que la nave)
    let bullets = [];
    const bulletSpeed = 12;

    function shoot() {
      if (playerDestroyed || isGameOver) return; // No disparar si el jugador est√° destruido o el juego termin√≥

      if (!firstShotFired) {
        if (!atmosphericSoundHasStarted && audioAtmosfera.paused) {
          playSound(audioAtmosfera);
          atmosphericSoundHasStarted = true;
        }
        firstShotFired = true;
      }

      playSound(audioLaser); // Sonido de l√°ser para cada disparo

      bullets.push({
        x: position.x,
        y: position.y,
        vx: Math.cos(angle) * bulletSpeed,
        vy: -Math.sin(angle) * bulletSpeed,
        life: 100
      });
    }

    // --- Explosion Particle System ---
    function createExplosion(x, y, color, count, minSize = 2, maxSize = 5, minLife = 20, maxLife = 60, minSpeed = 1, maxSpeed = 3) {
      for (let i = 0; i < count; i++) {
        const speedMagnitude = Math.random() * (maxSpeed - minSpeed) + minSpeed;
        const angle = Math.random() * Math.PI * 2;
        explosions.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speedMagnitude,
          vy: Math.sin(angle) * speedMagnitude,
          size: Math.random() * (maxSize - minSize) + minSize,
          life: Math.random() * (maxLife - minLife) + minLife,
          color: color,
          alpha: 1 // Initial alpha for fading
        });
      }
    }

    function updateExplosions() {
      for (let i = explosions.length - 1; i >= 0; i--) {
        const p = explosions[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.alpha = p.life / 40; // Simple fade out, adjust 40 based on max life, ensure it's based on initial life range

        if (p.life <= 0) {
          explosions.splice(i, 1);
        }
      }
    }

    function drawExplosions() {
      ctx.fillStyle = "white";
      explosions.forEach(p => {
        ctx.save();
        ctx.globalAlpha = Math.max(0, p.alpha); // Ensure alpha is not negative
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    // --- End Explosion Particle System ---

    // Explosiones
    let explosions = [];

    function explode(x, y, color = "orange") {
      for (let i = 0; i < 15; i++) {
        explosions.push({
          x, y,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 3,
          life: 20,
          color
        });
      }
    }

    // Marcianos estilo Space Invaders
    let martians = [];

    function drawMartian(x, y) {
      // Dibujar la imagen del invasor centrada
      if (invaderImage.complete && invaderImage.naturalWidth !== 0) {
        ctx.drawImage(invaderImage, x - invaderImgWidth / 2, y - invaderImgHeight / 2, invaderImgWidth, invaderImgHeight);
      } else {
        // Fallback por si la imagen no carga
        ctx.fillStyle = "purple"; // Color diferente para indicar error de carga
        ctx.fillRect(x - invaderImgWidth / 2, y - invaderImgHeight / 2, invaderImgWidth, invaderImgHeight); // Un simple cuadrado como placeholder
      }
    }

    function createMartian() {
      const x = Math.random() * (width - invaderImgWidth) + invaderImgWidth / 2;
      const y = invaderImgHeight / 2; // Start at the top, adjusted for center
      const vx = (Math.random() - 0.5) * 2 * martianBaseSpeedX; // Random horizontal speed
      const vy = martianBaseSpeedY; // Consistent vertical speed
      martians.push({ x, y, vx, vy, img: invaderImage, hasLanded: false });
    }

    function updateMartians() {
      if (gameIsOver) return;
      martians.forEach((martian, index) => {
        if (!martian.hasLanded) {
          // Movement for non-landed martians
          martian.x += martian.vx;
          martian.y += martian.vy;

          // Wall bouncing for non-landed martians
          if (martian.x - invaderImgWidth / 2 < 0 || martian.x + invaderImgWidth / 2 > width) {
            martian.vx *= -1;
          }

          // Check if martian reaches planet surface
          if (planeta.loaded && planeta.reachedTarget) {
            const planetRadius = planeta.width / 2;
            const planetCenterX_onCanvas = planeta.x + planetRadius;
            const planetCenterY_onCanvas = planeta.y + planetRadius; // Assumes planet image is circular and height == width

            const dxMartianToPlanetCenter = martian.x - planetCenterX_onCanvas;

            // Check if martian is horizontally within the planet's span for collision
            if (Math.abs(dxMartianToPlanetCenter) < planetRadius) {
              let termInsideSqrt = planetRadius * planetRadius - dxMartianToPlanetCenter * dxMartianToPlanetCenter;
              // Ensure term is not negative due to potential floating point inaccuracies if dx is very close to radius
              termInsideSqrt = Math.max(0, termInsideSqrt);
              // yOnPlanetSurface is the y-coordinate on the upper circumference of the planet at martian's x
              const yOnPlanetSurface = planetCenterY_onCanvas - Math.sqrt(termInsideSqrt);

              // Check if the martian's bottom edge touches or is below this surface point
              const landingDepthOffset = 1; // How many pixels 'into' the planet surface they should go
              if (martian.y + invaderImgHeight / 2 >= yOnPlanetSurface + landingDepthOffset) {
                martian.img = invaderRojoImage;
                martian.hasLanded = true;
                martian.vy = 0; // Stop vertical movement
                martian.vx = 0; // Stop horizontal movement
                // Position martian to sit on the surface, so its bottom edge is at yOnPlanetSurface + landingDepthOffset
                martian.y = (yOnPlanetSurface + landingDepthOffset) - invaderImgHeight / 2;
                // Initialize properties for landed jitter movement
                martian.originalLandedX = martian.x;
                martian.originalLandedY = martian.y;
                martian.jitterTargetX = martian.x; // Initial target is current position
                martian.jitterTargetY = martian.y;
                martian.jitterChangeTimer = 0;
              }
            }
          } else if (martian.y > height + invaderImgHeight) { // Off-screen check for non-landed martians
            martians.splice(index, 1); // Remove if off-screen
          }
        } else { // Martian has landed - apply slow drift jitter movement
          if (typeof martian.originalLandedX !== 'undefined') { // Ensure original positions are set
            const JITTER_RANGE = 20; // Total span (e.g., +/- 10px)
            const JITTER_TARGET_UPDATE_INTERVAL = 120; // Frames (e.g., 2 seconds at 60fps)
            const JITTER_DRIFT_SPEED = 0.02; // Lower is slower

            martian.jitterChangeTimer++;
            if (martian.jitterChangeTimer >= JITTER_TARGET_UPDATE_INTERVAL) {
              martian.jitterTargetX = martian.originalLandedX + (Math.random() - 0.5) * JITTER_RANGE;
              martian.jitterTargetY = martian.originalLandedY + (Math.random() - 0.5) * JITTER_RANGE;
              martian.jitterChangeTimer = 0;
            }

            // Drift towards the target
            martian.x += (martian.jitterTargetX - martian.x) * JITTER_DRIFT_SPEED;
            martian.y += (martian.jitterTargetY - martian.y) * JITTER_DRIFT_SPEED;
          }
        }
      });
    }


    function checkCollisionsWithMartians() {
      if (playerDestroyed || playerIsInvulnerable) return; // Don't check if destroyed or invulnerable

      for (let i = martians.length - 1; i >= 0; i--) {
        const m = martians[i];

        // Simplified distance check (center to center)
        const dx = m.x - position.x; // Martian center X - Player center X
        const dy = m.y - position.y; // Martian center Y - Player center Y
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Collision if distance is less than sum of half radii (using a factor for better feel)
        if (distance < (playerImgWidth / 2 + invaderImgWidth / 2) * 0.8) {
          playSound(audioPlayerExplosion);
          createExplosion(position.x, position.y, "red", 60, 2, 6, 30, 70, 1.5, 5.5); // Player explosion
          createExplosion(m.x, m.y, "orange", 40, 1, 5, 20, 55, 1, 4.5);      // Martian explosion
          martians.splice(i, 1); // Remove martian that hit the player

          playerLives--;
          updateUI(); // Update lives display immediately

          if (playerLives > 0) {
            // Respawn player
            position.x = width / 2;
            position.y = height - playerImgHeight / 2 - 10; // Reset position
            playerIsInvulnerable = true;
            playerInvulnerableTimer = playerInvulnerabilityDuration;
            // Player is not destroyed yet, game continues
          } else {
            // No lives left
            playerDestroyed = true;
            scheduleGameOverScreen(); // Trigger game over
          }
          break; // Collision handled, no need to check other martians for this frame
        }
      }
    }

    function drawMartians() {
      martians.forEach(martian => {
        // Dibujar la imagen del invasor centrada
        if (martian.img && martian.img.complete && martian.img.naturalWidth !== 0) {
          ctx.drawImage(martian.img, martian.x - invaderImgWidth / 2, martian.y - invaderImgHeight / 2, invaderImgWidth, invaderImgHeight);
        } else {
          // Fallback por si la imagen no carga o es el invaderRojo y no ha cargado
          ctx.fillStyle = martian.hasLanded ? "darkred" : "purple";
          ctx.fillRect(martian.x - invaderImgWidth / 2, martian.y - invaderImgHeight / 2, invaderImgWidth, invaderImgHeight);
        }
      });
    }

    // Puntuaci√≥n
    let score = 0;

    // Earth Health System
    const earthMaxHealth = 100;
    let earthCurrentHealth = earthMaxHealth;
    const damagePerLandedMartianPerFrame = 0.03; // Damage per landed martian per frame

    // Player Lives System
    let playerLives = 3;
    const playerInvulnerabilityDuration = 180; // 3 seconds at 60fps
    let playerIsInvulnerable = false;
    let playerInvulnerableTimer = 0;
    let planetHasExploded = false;

    function clearCanvas() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
      ctx.fillRect(0, 0, width, height);
    }




    function updatePlayer() {
      if (playerDestroyed) return;
      // Handle rotation
      if (keys.left) rotationSpeed += rotationAcceleration; // Pressing left should turn left (e.g. positive rotation for -angle)
      if (keys.right) rotationSpeed -= rotationAcceleration; // Pressing right should turn right (e.g. negative rotation for -angle)
      rotationSpeed = Math.max(-maxRotationSpeed, Math.min(maxRotationSpeed, rotationSpeed));
      rotationSpeed *= rotationDamping;
      angle += rotationSpeed;

      // Handle speed and movement
      if (keys.up) speed += accelerationFactor;
      else if (keys.down) speed -= accelerationFactor / 2; // Slower deceleration or braking
      else speed -= accelerationFactor / 4; // Natural deceleration if no input

      speed = Math.max(actualMinSpeed, Math.min(maxSpeed, speed));

      position.x += Math.cos(angle) * speed;
      position.y -= Math.sin(angle) * speed;

      // Boundary checks (simple wrap around)
      if (position.x > width + playerImgWidth / 2) position.x = -playerImgWidth / 2;
      if (position.x < -playerImgWidth / 2) position.x = width + playerImgWidth / 2;
      if (position.y > height + playerImgHeight / 2) position.y = -playerImgHeight / 2;
      if (position.y < -playerImgHeight / 2) position.y = height + playerImgHeight / 2;
    }

    function drawPlayer() {
      if (playerDestroyed || !playerImage.complete || playerImage.naturalWidth === 0) return;

      // Blinking effect during invulnerability
      if (playerIsInvulnerable && (playerInvulnerableTimer % 20 < 10)) { // Blink off for 10 frames, on for 10 frames
        return; // Skip drawing to make it blink
      }

      ctx.save();
      ctx.translate(position.x, position.y);
      ctx.rotate(-angle); // Player image 'nave.png' is assumed to point to the right by default
      ctx.drawImage(playerImage, -playerImgWidth / 2, -playerImgHeight / 2, playerImgWidth, playerImgHeight);
      ctx.restore();
    }

    function createStars() {
      for (let i = 0; i < 100; i++) {
        stars.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: Math.random() * 2 + 0.5 // Min size 0.5
          // speed property removed as stars are static
        });
      }
    }

    function updateStars() {
      // Stars are now static, so no updates to their positions needed here.
      // If parallax effect is desired later, it would be added here.
    }

    function drawStars() {
      ctx.fillStyle = "white";
      stars.forEach(star => {
        ctx.fillRect(star.x, star.y, star.size, star.size);
      });
    }

    function updateBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        bullet.x += bullet.vx;
        bullet.y += bullet.vy;
        bullet.life--;
        if (bullet.life <= 0 || bullet.x < 0 || bullet.x > width || bullet.y < 0 || bullet.y > height) {
          bullets.splice(i, 1);
        }
      }
    }

    function drawBullets() {
      ctx.fillStyle = "yellow";
      bullets.forEach(bullet => {
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2); // Bullet radius 3
        ctx.fill();
      });
    }

    function updateExplosions() {
      for (let i = explosions.length - 1; i >= 0; i--) {
        const p = explosions[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) {
          explosions.splice(i, 1);
        }
      }
    }

    function drawExplosions() {
      explosions.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 20; // Fade out
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.life / 3 + 2, 0, Math.PI * 2); // Size based on life, min radius 2
        ctx.fill();
        ctx.globalAlpha = 1.0; // Reset alpha
      });
    }

    function updatePlaneta() {
      if (planeta.loaded && !planeta.reachedTarget) {
        planeta.y -= planeta.speed; // Move up
        if (planeta.y <= planeta.targetY) {
          planeta.y = planeta.targetY;
          planeta.reachedTarget = true;
        }
      }
    }

    function drawPlaneta() {
      if (planetHasExploded || !planeta.loaded || !planeta.img || !planeta.img.complete || planeta.img.naturalWidth === 0) {
        return;
      }

      // Draw the base planet image
      ctx.drawImage(planeta.img, planeta.x, planeta.y, planeta.width, planeta.height);

      // Calculate damage intensity (0 = full health, 1 = zero health)
      const damageIntensity = Math.max(0, 1 - (earthCurrentHealth / earthMaxHealth));

      if (damageIntensity > 0) {
        ctx.save();
        // Apply red overlay, increasing opacity with damage
        // Max alpha for red overlay can be set (e.g., 0.7 for 70% red at max damage)
        ctx.globalAlpha = damageIntensity * 0.7;
        ctx.fillStyle = 'red';
        // Draw a circle over the planet area. Assuming planeta.x, planeta.y are top-left.
        // Planet's center is (planeta.x + planeta.width / 2, planeta.y + planeta.height / 2)
        // Radius is planeta.width / 2 (assuming it's roughly circular)
        ctx.beginPath();
        ctx.arc(planeta.x + planeta.width / 2, planeta.y + planeta.height / 2, planeta.width / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore(); // Restores globalAlpha and other canvas states
      }
    }


    function checkBulletMartianCollisions() {
      if (gameIsOver) return;
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        // Ensure bullet exists if it was spliced in the same frame by another martian collision
        if (!bullet) continue;

        for (let j = martians.length - 1; j >= 0; j--) {
          const m = martians[j];

          // Distance check between bullet center and martian center
          const dx = m.x - bullet.x;
          const dy = m.y - bullet.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Collision if distance is less than martian's half-width + bullet's effective radius
          if (distance < invaderImgWidth / 2 + 3) { // 3 is a small buffer for bullet size/hitbox
            playSound(audioInvaderDown); // Play martian destruction sound
            createExplosion(m.x, m.y, "yellow", 30, 1, 4, 15, 45, 1, 3.5); // Martian explosion
            martians.splice(j, 1);    // Remove martian
            bullets.splice(i, 1);     // Remove bullet
            score += 10;              // Increase score
            // Optional: Add logic to spawn new martian if desired
            // if (Math.random() < 0.1) createMartian(); 
            break; // Bullet is consumed, no need to check against other martians for this bullet
          }
        }
      }
    }

    function animate() {
      if (!gameHasStarted) { // Si el juego no ha comenzado, no hacer nada en este bucle
        // La animaci√≥n de fondo (estrellas) se maneja en initialBackgroundAnimation
        return;
      }
      if (gameIsOver) {
        // Game over message is handled by scheduleGameOverScreen
        // No need to call requestAnimationFrame again if game is over
        return;
      }

      requestAnimationFrame(animate);
      clearCanvas();

      updateStars();
      drawStars();

      updatePlaneta();
      drawPlaneta();

      // Handle player invulnerability timer
      if (playerIsInvulnerable) {
        playerInvulnerableTimer--;
        if (playerInvulnerableTimer <= 0) {
          playerIsInvulnerable = false;
        }
      }

      if (!playerDestroyed) {
        updatePlayer();
        drawPlayer();
      }

      updateBullets();
      drawBullets();

      updateMartians();
      drawMartians();
      updateExplosions(); // Update explosion particles
      drawExplosions();   // Draw explosion particles

      // Earth health drain by landed martians & game over check
      if (!gameIsOver && !playerDestroyed) {
        let landedMartiansOnPlanet = 0;
        for (const m of martians) {
          if (m.hasLanded) {
            landedMartiansOnPlanet++;
            earthCurrentHealth -= damagePerLandedMartianPerFrame;
          }
        }
        earthCurrentHealth = Math.max(0, earthCurrentHealth); // Prevent negative health

        if (earthCurrentHealth <= 0) {
          if (!planetHasExploded) { // Explode only once
            planetHasExploded = true;
            // Create a large explosion for the planet
            createExplosion(planeta.x + planeta.width / 2, planeta.y + planeta.height / 2, 'white', 500, 5, 30, 80, 200, 2, 10);
            playSound(audioEarthBang);
            // Optionally, add a screen shake here
          }
          playerDestroyed = true; // Player is also considered destroyed/game over
          scheduleGameOverScreen();
        } // Closes if (earthCurrentHealth <= 0)
      } // Closes if (!gameIsOver && !playerDestroyed)

      if (!playerDestroyed) { // Only check collisions if player is active
        checkCollisionsWithMartians(); // Player vs Martian
        checkBulletMartianCollisions(); // Bullet vs Martian
      }

      updateUI();

      // Continuously try to spawn a new martian
      if (Math.random() < 0.01) { // 2% chance per frame to spawn a martian
        createMartian();
      }
    }

    function updateUI() {
      // Usa la referencia global para el score si es necesario, o la local si est√° definida aqu√≠.
      // Para consistencia y evitar errores de scope, usamos la global.
      if (scoreDisplayGlobal) scoreDisplayGlobal.textContent = `Puntuaci√≥n: ${score}`;
      // const scoreDisplay = document.getElementById('score'); // Esta es local, si la prefieres, aseg√∫rate que est√© definida. Si no, usa la global.
      // scoreDisplay.textContent = `Puntuaci√≥n: ${score}`;
      if (earthHealthBarDiv) {
        const healthPercentage = (earthCurrentHealth / earthMaxHealth) * 100;
        earthHealthBarDiv.style.width = `${healthPercentage}%`;
      }

      // Update lives display
      if (livesDisplayDiv && playerImage.complete && playerImage.naturalWidth !== 0) {
        livesDisplayDiv.innerHTML = ''; // Clear existing life icons
        // Display icons for spare lives (playerLives - 1)
        // Ensure playerLives is at least 1 before trying to show N-1 icons
        const spareLivesToShow = Math.max(0, playerLives - 1);
        for (let i = 0; i < spareLivesToShow; i++) {
          const lifeIcon = document.createElement('img');
          lifeIcon.src = playerImage.src;
          // CSS will style the size via #livesIcons img
          livesDisplayDiv.appendChild(lifeIcon);
        }
      }
      // updateEarthHealthDisplay(); // Function removed
      // speedValue.textContent = `Velocidad: ${Math.abs(speed).toFixed(1)}`; // Control removed
    }

    function scheduleGameOverScreen() {
      if (gameIsOver || !playerDestroyed) return;

      // Primero, mostrar solo el mensaje de Game Over
      if (gameOverDiv && gameOverMessage && restartBtn) {
        gameOverMessage.style.display = "block";
        restartBtn.style.display = "none";
        gameOverDiv.style.display = "flex";
      }

      // Despu√©s de un tiempo, ocultar mensaje y mostrar bot√≥n
      setTimeout(() => {
        if (gameOverMessage) gameOverMessage.style.display = "none";
        if (restartBtn) restartBtn.style.display = "block";
        gameIsOver = true; // Detener el bucle de animaci√≥n principal aqu√≠ o dentro de animate()
      }, 3000); // 3 segundos para leer "Game Over", luego aparece el bot√≥n
    }

    function initializeOrResetGame() {
      // Ocultar pantalla de Game Over si estuviera visible
      if (gameOverDiv) gameOverDiv.style.display = "none";

      // Resetear variables del juego
      score = 0;
      playerLives = 3; // Restablecer a la cantidad inicial de vidas.
      earthHealth = MAX_EARTH_HEALTH; // Usar la constante definida

      // Resetear estado del jugador
      position.x = width / 2 - playerImgWidth / 2; // Posici√≥n inicial X (centrado)
      position.y = height - playerImgHeight - 30;  // Posici√≥n inicial Y (cerca del fondo)
      angle = 0; // √Ångulo inicial (ej. apuntando hacia arriba o adelante)
      speed = actualMinSpeed; // Restablecer a la velocidad m√≠nima/inicial
      rotationSpeed = 0; // Restablecer velocidad de rotaci√≥n
      playerDestroyed = false;
      playerIsInvulnerable = false; // Asegurarse de no ser invulnerable al inicio
      playerInvulnerableTimer = 0;

      // Resetear estado de las teclas
      keys.up = false;
      keys.down = false;
      keys.left = false;
      keys.right = false;

      // Resetear flags de sonido iniciales
      firstShotFired = false;
      atmosphericSoundHasStarted = false;
      // Parar y resetear sonidos si es necesario (ej. atm√≥sfera)
      if (audioAtmosfera && typeof audioAtmosfera.pause === 'function') {
        audioAtmosfera.pause();
        audioAtmosfera.currentTime = 0;
      }

      // Limpiar arrays de juego
      bullets = [];
      martians = [];
      explosions = [];

      // Recrear elementos iniciales
      createMartianInitialWave();
      // createStars(); // Las estrellas ya se crean y animan desde el inicio

      gameIsOver = false;
      gameHasStarted = true; // Marcar que el juego ha comenzado

      // Mostrar UI del juego
      if (scoreDisplayGlobal) scoreDisplayGlobal.style.display = 'block';
      if (earthHealthContainerGlobal) earthHealthContainerGlobal.style.display = 'flex'; // o 'block' seg√∫n dise√±o
      if (livesDisplayContainerGlobal) livesDisplayContainerGlobal.style.display = 'flex'; // o 'block'

      // Actualizar UI inmediatamente
      updateUI();

      // Reiniciar animaci√≥n principal del juego
      if (typeof animate === 'function') {
        animate();
      } else {
        console.error('La funci√≥n animate no est√° definida globalmente o no es accesible.');
      }
    }

    function restartGame() { // Esta funci√≥n ahora solo llama a la nueva funci√≥n de inicializaci√≥n
      initializeOrResetGame();
    }
    // Ocultar pantalla de Game Over
    if (gameOverDiv) gameOverDiv.style.display = "none";

    // Resetear variables del juego
    score = 0;
    playerLives = 3; // Restablecer a la cantidad inicial de vidas.
    earthHealth = MAX_EARTH_HEALTH; // Usar la constante definida

    // Resetear estado del jugador
    position.x = width / 2 - playerImgWidth / 2; // Posici√≥n inicial X (centrado)
    position.y = height - playerImgHeight - 30;  // Posici√≥n inicial Y (cerca del fondo)
    angle = 0; // √Ångulo inicial (ej. apuntando hacia arriba o adelante)
    speed = actualMinSpeed; // Restablecer a la velocidad m√≠nima/inicial
    rotationSpeed = 0; // Restablecer velocidad de rotaci√≥n
    playerDestroyed = false;

    // Resetear estado de las teclas
    keys.up = false;
    keys.down = false;
    keys.left = false;
    keys.right = false;

    // Resetear flags de sonido iniciales
    firstShotFired = false;
    atmosphericSoundHasStarted = false;
    // Si el sonido atmosf√©rico estaba en bucle, podr√≠as necesitar pararlo aqu√≠
    // audioAtmosfera.pause();
    // audioAtmosfera.currentTime = 0;

    // Limpiar arrays de juego
    bullets = [];
    martians = [];
    explosions = [];

    // Recrear elementos iniciales
    createMartianInitialWave();
    // Si tienes estrellas u otros elementos que se generan una vez, considera si deben recrearse.
    // createStars(); // Por ejemplo, si las estrellas deben cambiar o resetearse.

    gameIsOver = false;

    // Actualizar UI inmediatamente
    updateUI();

    // Reiniciar animaci√≥n
    if (typeof animate === 'function') {
      animate();
    } else {
      console.error('La funci√≥n animate no est√° definida globalmente o no es accesible.');
    }


    // A√±adir event listener al bot√≥n de reinicio
    if (restartBtn) {
      restartBtn.addEventListener('click', restartGame);
    }

    // Funci√≥n para crear la oleada inicial de marcianos (ejemplo)
    function createMartianInitialWave() {
      // L√≥gica para crear los marcianos iniciales, por ejemplo:
      for (let i = 0; i < 10; i++) { // Crear 10 marcianos como ejemplo
        setTimeout(createMartian, i * 500); // Espaciados en el tiempo
      }
    }

    // A√±adir event listener al bot√≥n de reinicio
    if (restartBtn) {
      restartBtn.addEventListener('click', restartGame);
    }

    // El juego ya no comienza autom√°ticamente.
    // Se iniciar√° con el bot√≥n de la pantalla de inicio.
    // PERO, necesitamos dibujar las estrellas desde el principio.
    createStars(); // Crear estrellas para el fondo inicial

    function initialBackgroundAnimation() {
      if (!gameHasStarted) {
        clearCanvas();
        updateStars();
        drawStars();
        requestAnimationFrame(initialBackgroundAnimation);
      } else {
        // Una vez que el juego ha comenzado, la animaci√≥n principal (animate()) toma el control.
        // Esta funci√≥n ya no necesita seguir ejecut√°ndose.
        return;
      }
    }

    // Event listener para el bot√≥n de INICIAR JUEGO
    // Asegurarse que startGameBtn no es null antes de a√±adir el listener
    // Event listener para el bot√≥n de INICIAR JUEGO
    if (startGameBtn) {
      console.log('Adding event listener to startGameBtn'); // DEBUG
      startGameBtn.addEventListener('click', () => {
        console.log('startGameBtn clicked!'); // DEBUG
        playSound(audioPremio);
        playSound(audioVoz);
        if (startScreenDiv) {
          console.log('Hiding startScreenDiv'); // DEBUG
          startScreenDiv.style.display = 'none';
        }
        console.log('Calling initializeOrResetGame from startGameBtn'); // DEBUG
        initializeOrResetGame();
      });
    }
    else {
      console.error('startGameBtn not found, cannot add event listener.'); // DEBUG
    }

    // Iniciar la animaci√≥n de fondo DESPU√âS de definir todo, incluyendo los listeners
    initialBackgroundAnimation();

  </script>
</body>

</html>